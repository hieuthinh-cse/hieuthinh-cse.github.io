---
title: 'Blog Post number 1'
date: 2012-08-14
permalink: /posts/2012/08/blog-post-1/
tags:
  - cool posts
  - category1
  - category2
---

This is a sample blog post. Lorem ipsum I can't remember the rest of lorem ipsum and don't have an internet connection right now. Testing testing testing this blog post. Blog posts are cool.

Headings are cool
======

You can have many headings
======

Căn bản về Apache Kafka
------
Apache Kafka là platform streaming phân tán nổi tiếng. Nó được dùng để xây dựng các pipeline dữ liệu real-time, nhưng bởi tính persistence (bền bỉ) của các topic, nó cũng có thể sử dụng như kho lưu trữ streaming message để xử lý dữ liệu lịch sử. Để có thể cải thiện tính mở rộng (scalability), topic của Kakka bao gồm các partition (phân vùng). Đi vào chi tiết hơn, một partition đại diện cho một file chỉ-có-thêm vào (append-only). Sử dụng một cấu trúc dữ liệu đơn giản nên throughput (thông lượng) rất cao. Cấu trúc bên trong topic cũng có ý nghĩa rất quan trọng — chúng ta chỉ có thể consume các message từ một topic partition từng cái một (one by one) theo thứ tự.

Cấu trúc thứ tự (sequential anatomy) của một topic partition được trình bày như hình dưới:
![alt text](https://images.viblo.asia/b0692825-2554-47c1-8c40-0444964c85eb.png "Logo Title Text 1")

Các vấn đề khi xử lý message
------
Sự hiện thực hóa (implementation) của một consumer — xử lý message ngay lập tức ngay khi nhận từ Kafka topic rất đơn giản (straightforward). Không may thay, hiện thực cực kỳ phức tạp mà xử lý message có thể thất bại (fail) bới vì nhiều lý do khác nhau. Một số trong đó là các vấn đề thương xuyên (permanent problems), như lỗi về ràng buộc cơ sở dữ liệu (failure on the database constraint) hoặc định dạng message không hợp lệ. Một số khác, như tính tạm thời không có sẵn (temporary unavailability) của hệ thống phụ thuộc (dependent system) liên quan tới xử lý (handling) message, có thể được giải quyết (resolved) trong tương lai. Trong những trường hợp đó, thử lại (retry) quá trình xử lý message có thể là giải pháp hiệu quả (valid solution).

Logic retry căn bản
------
Cách căn bản nhất (simplest form), chúng ta có thể retry xử lý message vô thời hạn (indefinitely) với một số delay cố định giữa các lần retry tiếp theo (subsequent retries). Pseudo-code ví dụ của consumer có thể giống như sau:
```java
void consumeMainTopicWithSimpleRetry() {
    while (true) {
        boolean processedSuccessfully = true;
        Message message = takeNextMessage("main_topic");
        do {
            try {
                process(message);
            } catch (Exception ex) {
                waitSomeTime();
                processedSuccessfully = false;
                LOGGER.warn("Message processing failure. Will try once again.", ex);
            }
        } while (!processedSuccessfully);
    }
}
```
Logic retry non-blocking
------
Trong các hệ thống streaming, như Kafka, chúng ta không thể skip các message và quay lại xử lý chúng sau. Một khi chúng ta dịch pointer (con trỏ), còn được gọi là offset trong Kafka, của message hiện tại chúng ta không thể trở lại. Để cho đơn giản, cho rằng offset của consumer được ghi nhớ chỉ sau khi xử lý hiện tại thành công. Trong trường hợp này chúng ta không thể lấy message tiếp theo trừ khi xử lý hiện tại thành công. Nếu xử lý một message bị lỗi liên tục, nó sẽ ngăn hệ thống xử lý các message tiếp theo. Hiển nhiên chúng ta muốn tránh những kịch bản (scenario) như vậy bởi vì sự thất bại của việc xử lý message không có nghĩa message sau cũng vậy. Hơn nữa, sau một thời gian dài, ví dụ 1 giờ, quá trình message lỗi có thể thành công bởi những lý do khác nhau. Một trong số đó là khi hệ thống mà chúng ta phụ thuộc vào, đã hoạt động trở lại. Chúng ta phải làm sao để cải thiện sự hiện thực ngờ nghệch (naive) này? Khi xử lý message lỗi, ta có thể publish một copy của message vào một topic khác và đợi message tiếp sau. Gọi topic mới này là ‘retry_topic’. Cosumer của ‘retry_topic’ sẽ nhận message từ Kafka và sẽ đợi thới thiểm điểm xác định (predefined time), ví dụ 1 giờ, trước khi xử lý message. Các này, ta có thể trì hoãn nỗ lực xử lý message mà hề có bất kỳ tác động tới consumer của ‘main_topic’. Nếu quá trình trong consumer của ‘retry_topic’ lỗi, ta chỉ cần từ bỏ và lưu message vào ‘failed_topic’ cho các xử lý thủ công sau này về vấn đề này. Code cosumer của ‘main_topic’ có thể giống như sau:

```java
void consumeMainTopicWithPostponedRetry() {
    while (true) {
        Message message = takeNextMessage("main_topic");
        try {
            process(message);
        } catch (Exception ex) {
            publishTo("retry_topic");
            LOGGER.warn("Message processing failure. Will try once again in the future.", ex);
        }
    }
}
```

Và code của consumer ‘retry_topic’:
```java
void consumeRetryTopic() {
    while (true) {
        Message message = takeNextMessage("retry_topic");
        try {
            process(message);
            waitSomeLongerTime();
        } catch (Exception ex) {
            publishTo("failed_topic");
            LOGGER.warn("Message processing failure. Will skip it.", ex);
        }
    }
}
```
